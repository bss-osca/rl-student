---
title: "Module 6 - Notes and Exercises"
author: "<Your Name>"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: yes
    theme: journal
    highlight: haddock
    code_folding: hide
    fig_caption: yes
---


```{r, code = readLines("setup.R"), cache = FALSE, include=FALSE}
```

```{r}
knitr::opts_chunk$set(
   echo = TRUE
)
```


# Monte Carlo methods for prediction and control {#mod-mc}

The term "Monte Carlo" (MC) is often used for an estimation method which involves a random component. MC methods of RL learn state and action values by sampling and averaging returns. MC do not use dynamics where we estimate the value in the current state using the value in the next state (like in dynamic programming). Instead the MC methods estimate the values by considering different *sample-paths* (state, action and reward realizations). Compared to a Markov decision process, MC methods are model-free since they not require full knowledge of the transition probabilities and rewards (a model of the environment) instead MC methods learn the value function directly from experience. Often though, the sample-path is generated using simulation, i.e. some knowledge about the environment is given, but it is only used to generate sample transitions. For instance, consider an MDP model for the game Blackjack. Here calculating all the transition probabilities may be tedious and error-prone in terms of coding and numerical precision. Instead we can simulate a game (a sample-path) and use the simulations to evaluate/predict the value function of a policy and then use control to find a good policy. That is, we still use a generalised policy iteration framework, but instead of computing the value function using the MDP model a priori, we learn it from experience. 

MC methods can be used for processes with episodes, i.e. where there is a terminal state. This reduces the length of the sample-path and the value of the states visited on the path can be updated based on the reward received.


## Learning outcomes 

By the end of this module, you are expected to:

* Identify the difference between model-based and model-free RL.
* Identify problems that can be solved using Monte-Carlo methods.
* Describe how MC methods can be used to estimate value functions from sample data.
* Do MC prediction to estimate the value function for a given policy.
* Explain why it is important to maintain exploration in MC algorithms.
* Do policy improvement (control) using MC in a generalized policy improvement algorithm.
* Compare different ways of exploring the state-action space.
* Argue why off-policy learning can help deal with the exploration problem.
* Use importance sampling to estimate the expected value of a target distribution using samples from a different distribution.
* Use importance sampling in off-policy learning to predict the value-function of a target policy.
* Explain how to modify the MC prediction and improvement algorithm for off-policy learning.

The learning outcomes relate to the [overall learning goals](#mod-lg-course) number 3, 4, 9 and 12 of the course.

<!-- SOLO increasing: identify · memorise · name · do simple procedure · collect data · -->
<!-- enumerate · describe · interpret · formulate · list · paraphrase · combine · do -->
<!-- algorithms · compare · contrast · explain causes · analyse · relate · derive · -->
<!-- evaluate · apply · argue · theorise · generalise · hypothesise · solve · reflect -->


## Textbook readings

For this week, you will need to read Chapter 5-5.7 in @Sutton18. Read it before continuing this module. A summary of the book notation can be seen [here][sutton-notation].

```{r, echo=FALSE}
link_slide_file_text("06", "mc")
```

## MC prediction (evaluation)

Given a policy $\pi$, we want to estimate the state-value function. Recall that the state value function is 
\[
v_\pi(s) = \mathbb{E}_\pi[G_t | S_t = s].
\]
where the return is 
\[
G_t = R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \cdots = \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} = R_{t+1} + \gamma G_{t+1}
\]
Now given policy $\pi$ and a sample-path (episode) $S_0, A_0, R_1, S_1, A_1, \ldots, S_{T-1}, A_{T-1}, R_T$ ending in the terminal state at time $T$, we can calculate the realized return for each state in the sample-path. Each time we have a new sample-path a new realized return for the states is given and the average for the returns in a state is an estimate of the state-value. With enough observations, the sample average converges to the true state-value under the policy $\pi$.

Given a policy $\pi$ and a set of sample-paths, there are two ways to estimate the state values $v_\pi(s)$:

* First visit MC: average returns from first visit to state $s$.
* Every visit MC: average returns following every visit to state $s$.

First visit MC generates iid estimates of $v_\pi(s)$ with finite variance, so the sequence of estimates converges to the expected value by the law of large numbers as the number of observations grow. Every visit MC does not generate independent estimates, but still converges.

An algorithm for first visit MC is given in Figure \@ref(fig:mc-prediction-alg). The state-value estimate is stored in a vector $V$ and the returns for each state in a list. Given a sample-path we add the return to the states on the path by scanning the path backwards and updating $G$. Note since the algorithm considers first visit MC, a check of occurrence of the state earlier in the path done. If this check is dropped, we have a every visit MC algorithm instead. Moreover, the computation needed to update the state-value does not depend on the size of the process/MDP but only of the length of the sample-path.

```{r mc-prediction-alg, echo=FALSE, fig.cap="MC policy prediction [@Sutton18]."}
knitr::include_graphics("img/mc-prediction.png")
```

The algorithm maintains a list of all returns for each state which may require a lot of memory. Instead as incremental update of $V$ can be done. Adapting Eq. \@ref(eq:avg), we have that the sample average can be updated using: 

$$
  V(s) \leftarrow V(s) + \frac{1}{n} \left[G - V(s)\right].
$$
where $n$ denote the number of realized returns found for state $s$ and $G$ the current realized return. The state-value vector must be initialized to zero and a vector counting the number of returns found for each state must be stored.


<!-- ### Blackjack - MC prediction -->


### MC prediction of action-values

With a model of the environment we only need to estimate the state-value function, since it is easy to determine the policy from the state-values using the Bellman optimality equations \@ref(eq:bell-opt-state-policy). However, if we do not know the expected reward and transition probabilities state values are not enough. In that case, it is useful to estimate action-values since the optimal policy can be found using $q_*$ (see Eq. \@ref(eq:bell-opt-state-policy)). To find $q_*$, we first need to predict action-values for a policy $\pi$. This is essentially the same as for state-values, only we now talk about state-action pairs being visited, i.e. taking action $a$ in state $s$ instead. 

If $\pi$ is deterministic, then we will only estimate the values of actions that $\pi$ dictates. Therefore some exploration are needed in order to have estimates for all action-values. Two possibilities are:

1. Make $\pi$ stochastic, e.g. $\varepsilon$-soft that that have non-zero probability of selecting each state-action pair. 
2. Use *exploring starts*, which specifies that ever state-action pair has non-zero probability of being selected as the starting state of an sample-path. 


## MC control (improvement)

We are now ready to formulate a generalized policy iteration (GPI) algorithm using MC to predict the action-values $q(s,a)$. Policy improvement is done by selecting the next policy greedy with respect to the action-value function:
\[
    \pi(s) = \arg\max_a q(s, a).
\]
That is, we generate a sequence of policies and action-value functions
$$\pi_0 \xrightarrow[]{E} q_{\pi_0} \xrightarrow[]{I} \pi_1 \xrightarrow[]{E} q_{\pi_1} \xrightarrow[]{I} \pi_2 \xrightarrow[]{E} q_{\pi_2} \xrightarrow[]{I} \ldots \xrightarrow[]{I} \pi_* \xrightarrow[]{E} q_{*}.$$
Hence the policy improvement theorem applies for all $s \in \mathcal{S}$:

\begin{align}
    q_{\pi_k}(s, a=\pi_{k+1}(s)) &= q_{\pi_k}(s, \arg\max_a q_{\pi_k}(s, a)) \\
                    &= \max_a q_{\pi_k}(s, a) \\
                    &\geq q_{\pi_k}(s, \pi_k(s))\\
                    &= v_{\pi_k}(s)
\end{align}

That is, $\pi_{k+1}$ is better than $\pi_k$ or optimal. 

It is important to understand the major difference between model-based GPI (remember that a model means the transition probability matrix and reward distribution are known) and model-free GPI. We cannot simply use a 100% greedy strategy all the time, since all our action-values are estimates. As such, we now need to introduce an element of exploration into our algorithm to estimate the action-values. For convergence to the optimal policy a model-free GPI algorithm must satisfy:

1. *Infinite exploration*: all state-action $(s,a)$ pairs should be explored infinitely many times as the number of iterations go to infinity (in the limit), i.e. as the number of iterations $k$ goes to infinity the number of visits $n_k$ does too $$\lim_{k\rightarrow\infty} n_k(s, a) = \infty.$$
2. *Greedy in the limit*: while we maintain infinite exploration, we do eventually need to converge to the optimal policy:
  $$\lim_{k\rightarrow\infty} \pi_k(a|s) = 1 \text{ for } a = \arg\max_a q(s, a).$$

### GPI with exploring starts

An algorithm using exploring starts and first visit MC is given in Figure \@ref(fig:mc-gpi-es-alg). It satisfies the convergence properties and and incremental implementation can be used to update $Q$. Note that to predict the action-values for a policy, we in general need a large number of sample-paths. However, much like we did with value iteration, we do not need to fully evaluate the value function for a given policy. Instead we can merely move the value toward the correct value and then switch to policy improvement thereafter. To stop the algorithm from having infinitely many sample-paths we may stop the algorithm once the $q_{\pi_k}$ stop moving within a certain error.

```{r mc-gpi-es-alg, echo=FALSE, fig.cap="GPI using MC policy prediction with exploring starts [@Sutton18]."}
knitr::include_graphics("img/mc-gpi-es.png")
```

<!-- ### Blackjack - MC control -->

### GPI using $\epsilon$-soft policies

Note by using exploring starts in Algorithm \@ref(fig:mc-gpi-es-alg), the 'infinite exploration' convergence assumption is satisfied. However exploring starts may be hard to use in practice. Another approach to ensure infinite exploration is to use a soft policy, i.e. assign a non-zero probability to each possible action in a state. An on-policy algorithm using $\epsilon$-greedy policies is given in Figure \@ref(fig:mc-gpi-on-policy-alg). Here we put probability $1 - \varepsilon + \frac{\varepsilon}{|\mathcal{A}(s)|}$ on the maximal action and $\frac{\varepsilon}{|\mathcal{A}(s)|}$ on each of the others. Note using $\epsilon$-greedy policy selection will improve the current policy; otherwise we have found best policy amongst the $\epsilon$-soft policies. If we want to find the optimal policy we have to ensure the 'greedy in the limit' convergence assumption. This can be done by decreasing $\epsilon$ as the number of iterations increase (e.g. $\epsilon = 1/k$).

```{r mc-gpi-on-policy-alg, echo=FALSE, fig.cap="On-policy GPI using MC policy prediction [@Sutton18]."}
knitr::include_graphics("img/mc-gpi-on-policy.png")
```


## Off-policy MC prediction {#sec-mc-off-policy}

Until now we have only considered what is denoted *on-policy* algorithms for finding the optimal policy. Here we both evaluate or improve the policy that is used to make decisions. To ensure infinite exploration we use for instance exploring starts or $\epsilon$-soft policies. *Off-policy* methods use a different approach by considering two policies: a policy $b$ used to generate the sample-path (behaviour policy) and a policy $\pi$ that is learned for control (target policy). We update the target policy using the sample-paths from the behaviour policy. The behaviour policy explores the environment for us during training and must ensure infinite exploration. Moreover, the *coverage* assumption must be satisfied: $$\pi(a|s) > 0 \rightarrow b(a|s) > 0$$ That is, every action in $\pi$ must also be taken, at least occasionally, by $b$. Put differently, to learn $\pi$ we must sample paths that occur when using $\pi$. Note target policy $\pi$ may be deterministic by using greedy selection with respect to action-value estimates (greedy in the limit satisfied).

Off-policy learning methods are powerful and more general than on-policy methods (on-policy methods being a special case of off-policy where target and behaviour policies are the same). They can be used to learn from data generated by a conventional non-learning controller or from a human expert.

But how do we estimate the expected return using the target policy when we only have sample-paths from the behaviour policy? For this we need to introduce *importance sampling*, a general technique for estimating expected values under one distribution given samples from another. Let us first explain it using two distributions $a$ and $b$ where we want to estimated the mean of $a$ given data/samples from $b$, then
$$
\begin{align}
  \mathbb{E}_{a}[X] &= \sum_{x\in X} a(x)x \\
  &= \sum_{x\in X} a(x)\frac{b(x)}{b(x)}x \\
  &= \sum_{x\in X} b(x)\frac{a(x)}{b(x)}x \\
  &= \sum_{x\in X} b(x)\rho(x)x \\
  &= \mathbb{E}_{b}\left[\rho(X)X\right].
\end{align}
$$
Hence to the mean of $a$ can be found by finding the mean of $\rho(X)X$ where $X$ is has a $b$ distribution and $\rho(x) = a(x)/b(x)$ denote the *importance sampling ratio*. Note given samples $(x_1,\ldots,x_n)$ from $b$ we then can calculate the sample average using
$$
\begin{align}
  \mathbb{E}_{a}[X] &= \mathbb{E}_{b}\left[\rho(X)X\right] \\
  &\approx \frac{1}{n}\sum_{i = 1}^n \rho(x_i)x_i \\
\end{align}
(\#eq:is-approx)
$$


<!-- Example with two distributions -->

Now let us use importance sampling on the target policy $\pi$ and behaviour policy $b$. Given state $S_t$ and sample path, we want to find 
$$v_\pi(s) = \mathbb{E}_{\pi}[G_t|S_t = s] = \mathbb{E}_{b}[\rho(G_t)G_t|S_t = s],$$
or since we base our estimates on sample-paths, we are in fact interested in estimating the action-values 
$$q_\pi(s,a) = \mathbb{E}_{\pi}[G_t|S_t = s, A_t = a] = \mathbb{E}_{b}[\rho(G_t)G_t|S_t = s, A_t = a].$$
For this we need the importance sampling ratio given a certain sample-path $S_t, A_t, R_{t+1}, \ldots, R_T, S_T$ with return $G_t$:
$$
\begin{align}
    \rho(G_t) &= \frac{\Pr{}(S_t, A_t, \dots S_T| S_t = s, A_t = a, \pi)}{\Pr{}(S_t, A_t, \dots, S_T)| S_t = s, A_t = a, b)} \\
                 &= \frac{\prod_{k=t}^{T-1}\pi(A_k|S_k)\Pr{}(S_{k+1}|S_k, A_k)}{\prod_{k=t}^{T-1}b(A_k|S_k)\Pr{}(S_{k+1}|S_k, A_k)}\\
                 &=\prod_{k=t}^{T-1}\frac{\pi(A_k|S_k)}{b(A_k|S_k)}.
\end{align}
(\#eq:isr)
$$
Note the transition probabilities cancel out, i.e. the ratio does not depend on the MDP dynamics by only the policies. Moreover, importance sampling ratios are only non-zero for sample-paths where the target-policy has non-zero probability of acting exactly like the behaviour policy $b$. So, if the behaviour policy takes 10 steps in an sample-path, each of these 10 steps have to have been possible by the target policy, else $\pi(a|s) = 0$ and $\rho_{t:T-1} = 0$.

We can now approx. $q_\pi(s,a)$ by rewriting Eq. \@ref(eq:is-approx) for $\pi$ given returns from $b$ to
$$
    q_\pi(s,a) = \mathbb{E}_{\pi}[G_t|S_t = s, A_t = a] \approx \frac{1}{n} \sum_{i = 1}^n \rho_iG_i,
    (\#eq:ois)
$$
where we assume that given the sample-paths (episodes), have $n$ observations of the return $(G_1, \ldots, G_n)$ in state $s$ taking action $a$ with the  importance sampling ratio $\rho_i$ calculated using Eq. \@ref(eq:isr). As a result if we consider the prediction algorithm in Figure \@ref(fig:mc-prediction-alg) it must be modified by:

* Generate an sample-path using policy $b$ instead of $\pi$.
* Add a variable W representing the importance sampling ratio which must be set to 1 on line containing $G \leftarrow 0$.
* Modify line $G \leftarrow \gamma G + R_{t+1}$ to $G \leftarrow \gamma WG + R_{t+1}$ since we now need to multiply with the importance sampling ratio.
* Add a line after the last with $W \leftarrow W \pi(A_t|S_t)/b(A_t|S_t)$, i.e. we update the importance sampling ratio.
* Note if $\pi(A_t|S_t) = 0$ then we may stop the inner loop earlier ($W=0$ for the remaining $t$). 
* Finally, an incremental update of $V$ can be done having a vector counting the number of of returns found for each state. Then the incremental update is 
$$
  V(s) \leftarrow V(s) + \frac{1}{n} \left[WG - V(s)\right].
  (\#eq:upd)
$$
where $n$ denote the number of realized returns found for state $s$ and $G$ the current realized return. 

### Weighted importance sampling 

When using a sample average the importance sampling method is called *ordinary importance sampling*. Ordinary importance sampling may result in a high variance which is not good. As a result we may use other weights and instead of Eq. \@ref(eq:ois) use the estimate (*weighted importance sampling*):
$$
    q_\pi(s,a) = \mathbb{E}_{\pi}[G_t|S_t = s, A_t = a] \approx \frac{1}{\sum_{i = 1}^n \rho_i} \sum_{i = 1}^n \rho_iG_i.
$$
An incremental update then becomes:

$$
\begin{align}
    q_\pi(s,a) &\approx V_{n+1} \\
    &= \frac{1}{\sum_{i = 1}^n \rho_i} \sum_{i = 1}^n \rho_iG_i \\
    &= \frac{1}{C_n} \sum_{i = 1}^n W_iG_i \\
    &= \frac{1}{C_n} (W_nG_n + C_{n-1}\frac{1}{C_{n-1}} \sum_{i = 1}^{n-1} W_iG_i) \\
    &= \frac{1}{C_n} (W_nG_n + C_{n-1}V_n) \\
    &= \frac{1}{C_n} (W_nG_n + (C_{n} - W_{n}) V_n) \\
    &= \frac{1}{C_n} (W_nG_n + C_{n}V_n - W_{n} V_n) \\
    &= V_n + \frac{W_n}{C_n} (G_n  - V_n),
\end{align}
(\#eq:wpd)
$$
where $C_n = \sum_{i = 1}^n \rho_i$ is the sum of the ratios and and $W_n$ the ratio for the n'th return. Using weighted importance sampling gives a smaller variance and hence faster convergence. An off-policy prediction algorithm using weighted importance sampling and incremental updates is given in Figure \@ref(fig:mc-pred-off-policy-alg). 

```{r mc-pred-off-policy-alg, echo=FALSE, fig.cap="Off-policy MC prediction [@Sutton18]."}
knitr::include_graphics("img/mc-off-policy-prediction.png")
```

Note both Eq. \@ref(eq:upd) and Eq. \@ref(eq:wpd) follows the general incremental formula: 
\begin{equation}
New Estimate \leftarrow Old Estimate + Step Size \left[Observation - Old Estimate \right].
\end{equation}
For ordinary importance sampling the step-size is $1/n$ and for weighted importance sampling the step-size is $W_n/C_n$.


## Off-policy control (improvement)

Having a discussed a framework for off-policy MC prediction, we can now give a GPI algorithm for off-policy MC control that estimate $\pi_*$ and $q_*$ by using rewards obtained through behaviour policy $b$. We will focus on using weighted importance sampling with incremental updates. The algorithm is given in Figure \@ref(fig:mc-gpi-off-policy-alg). The target policy $\pi$ is the greedy policy with respect to $Q$, which is an estimate of $q_\pi$. This algorithm converges to $q_\pi$ as long as an infinite number of returns are observed for each state-action pair. This can be achieved by making $b$ $\varepsilon$-soft. The policy $\pi$ converges to $\pi_*$ at all encountered states even if $b$ changes (to another $\varepsilon$-soft policy) between or within sample-paths. Note we exit the inner loop if $A_t \neq \pi(S_t)$ which implies $W=0$.

```{r mc-gpi-off-policy-alg, echo=FALSE, fig.cap="Off-policy GPI [@Sutton18]."}
knitr::include_graphics("img/mc-off-policy-gpi.png")
```

Notice that this policy only learns from sample-paths in which $b$ selects only greedy actions after some timestep. This can greatly slow learning.


## Summary 

Read Chapter 5.10 in @Sutton18.


## Exercises



### Exercise - Seasonal inventory and sales planning {#ex-mc-seasonal}

```{r RL env seasonal, include=FALSE}
library(R6)
library(hash)
library(tidyverse)

#' R6 Class representing the RL environment for the problem
RLEnvSeasonal <- R6Class("RLEnvSeasonal",
   public = list(
      
      #' @field maxInv Max inventory level.
      maxInv = NA,  
      
      #' @field maxT Max number of weeks to sell product.
      maxT = NA,
      
      #' @field scrapPrice Scrap price per item in week maxT.
      scrapPrice = NA,
      
      #' @field purchasePrice Purchase price per item.
      purchasePrice = NA,
      
      #' @field prices Possible sales prices per item.
      prices = NA,

      #' @description Create an object (when call new).
      #' @param maxInv Max inventory level.
      #' @param maxT Max number of weeks to sell product.
      #' @param scrapPrice Scrap price per item in week maxT.
      #' @param purchasePrice Purchase price per item.
      #' @return The new object.
      initialize = function(maxInv, maxT, scrapPrice, purchasePrice, prices) {
         self$maxInv <- maxInv 
         self$maxT <- maxT
         self$scrapPrice <- scrapPrice
         self$purchasePrice <- purchasePrice
         self$prices <- prices
      },
      
      
      #' @description Return all states (keys).
      getStates = function() {
         states <- expand_grid(l = 1:env$maxInv, t = 1:env$maxT) %>% mutate(s = str_c(l, ",", t)) %>% pull(s)
         states <- c(states, "0")
         return(states)
      },
      
      #' @description Return all actions (keys) for a state.
      #' @param s State considered.
      getActions = function(s) {
         if (s == "0") return("dummy")
         q <- str_split(s, ",", simplify = T)
         t <- as.numeric(q[2])
         q <- as.numeric(q[1])
         if (t == self$maxT) return(str_c(self$scrapPrice))
         return(str_c(self$prices))
      },
      
      #' @description Stochastic demand sample. 
      #' @param price Sales price.
      #' @param t Week.
      getDemand = function(price, t) {
         l1 = matrix(c(10,20, 12,12), ncol = 2, byrow = T)  # points (price, demand) for first line
         l2 = matrix(c(12,12, 15,10), ncol = 2, byrow = T)  
         l3 = matrix(c(15,10), ncol = 2, byrow = T)  
         
         if (price <= max(l1[1,1],l1[2,1])) {
            a <- (l1[1,2]-l1[2,2])/(l1[1,1]-l1[2,1])
            b <- l1[1,2] - a * l1[1,1] 
            d <- a * price + b 
            dS <- d * runif(1, 0.75, 1.25)
         } else if (price >= min(l2[1,1],l2[2,1]) & price <= max(l2[1,1],l2[2,1])) {
            a <- (l2[1,2]-l2[2,2])/(l2[1,1]-l2[2,1])
            b <- l2[1,2] - a * l2[1,1] 
            d <- a * price + b 
            dS <- d * runif(1, 0.75, 1.25)
         } else if (price >= l3[1,1]) {
            d <- -4*log(price - l3[1,1] + 1) + l3[1,2]
            dS <- d * runif(1, 1, 2)
         }
         if (t <= self$maxT/2) {
            dS <- runif(1, 1, 1.2) * dS
         }
         # if (stochastic) return(round(dS)) else return(round(d))
         return(round(dS))
      },
      
      #' @description Returns the simulated transition probabilities and reward. 
      getTransPrR = function(s, a, runs = 10000) {
         q <- str_split(s, ",", simplify = T)
         t <- as.numeric(q[2])
         q <- as.numeric(q[1])
         if (q == 0) {
            return(list(pr = c("0" = 1), r = 0))
         }
         if (t == env$maxT) {
            return(list(pr = c("0" = 1), r = env$scrapPrice * q))
         }
         a <- as.numeric(a)
         df <- tibble(sim = 1:runs) %>% 
            rowwise() %>% 
            mutate(demand = self$getDemand(a, t)) %>% 
            ungroup() %>% 
            mutate(qN = q - pmin(q, demand), reward = a * pmin(q, demand))
         reward <- mean(df$reward)
         if (t == 1) reward <- reward - q * self$purchasePrice
         df <- df %>% 
            count(qN) %>% 
            mutate(pr = n/sum(n), qN = if_else(qN == 0, "0", str_c(qN, ",", t+1)))
         pr <- df %>% pull(pr, name = qN)
         return(list(pr = pr, r = reward))
      },
      
      #' @description Returns an episode as a tibble with cols s, a, r (last col the terminal reward).
      #' @param agent The agent that holds the model with current policy.
      getEpisode = function(agent, q = sample(1:self$maxInv, 1)) {
         df <- tibble(s = rep(NA_character_, 100 * self$maxInv), a = NA_character_, r = NA_real_)  # a tibble with more rows than used
         # q <- sample(1:self$maxInv, 1)  # pick start inventory random
         # q <- 1
         t <- 1
         for (i in 1:nrow(df)) {
            if (q == 0) {
               df <- df[1:(i-1),]  # remove unused rows
               break  # have reached terminal state
            }
            s <- str_c(q, ",", t)
            if (t == self$maxT) { # sell remaining
               a <- names(agent$model[[s]]$pi)  # only a single action
               r <- self$scrapPrice * q
               q <- 0  # new q value
            } else {
               actions <- names(agent$model[[s]]$pi)
               a <- actions[sample(1:length(actions), 1, prob = agent$model[[s]]$pi)]
               # cat(a, " ")
               price <- as.numeric(a)
               d <- self$getDemand(price, t)
               if (t == 1) {
                  r <- price * min(q, d) - q * self$purchasePrice
               } else {
                  r <- price * min(q, d)
               }
               q <- q - min(q, d)  # new q value
               t <- t + 1 # new t value
            }
            df$s[i] <- s
            df$a[i] <- a
            df$r[i] <- r
         }
         return(df)
      }
   )
)
```

```{r, include=FALSE}
env <- RLEnvSeasonal$new(maxInv = 200, maxT = 20, scrapPrice = 5, purchasePrice = 14, prices = c(10, 15, 25))
```


```{r mdp-class, include=FALSE, eval=FALSE}
library(R6)
library(hash)
library(tidyverse)

#' R6 Class representing the MDP
#' 
#' Note since the MDP is a model with full information, we combine the agent and environment into a single class.
MDPClass <- R6Class("MDPClass",
   public = list(
      
      #' @field model The Markov decision process (model). The model is represented 
      #' using a hash list for the states. Each states contains a list with `actions`: a hash 
      #' list with actions and `pi` a vector with policy pr (named vector with only 
      #' positive values). The `actions` hash list contains actions with trans 
      #' pr `pr` (named vector only with positive values) and expected reward `reward`.
      model = NULL,  
      
      #' @field sV The state-values stored in a hash. Value updates are done in-place (one-array version).
      v = NULL,
      
      #' @description Create an object (when call new).
      #' @return The new object.
      initialize = function() {
         self$model <- hash()
         self$v <- hash()
      },
      
      #' @description Add the states (keys/strings in the hash)
      #' @param s A vector of states (converted to strings).
      addStateSpace = function(s) {
         keys <- make.keys(s)
         self$model[keys] <- list(pi = NA)   # don't use pi = NULL since then won't be defined 
         self$setStateValue()  # so v defined
         return(invisible(NULL))
      },
      
      #' @description Add the actions to a state
      #' @param stateStr State key/string.
      #' @param a A vector of actions (converted to strings).
      addActionSpace = function(stateStr, a) {
         a <- make.keys(a)
         self$model[[stateStr]]$actions <- hash()
         self$model[[stateStr]]$actions[a] <- NA
         return(invisible(NULL))
      },
      
      #' @description Add expected reward and trans pr to an action
      #' @param stateStr State key/string.
      #' @param actionStr Action key/string.
      #' @param r The expected reward.
      #' @param pr A named vector with positive trans pr. The name of an element must be the state key.
      addAction = function(stateStr, actionStr, r, pr) {
         if (!has.key(stateStr, self$model)) {
            self$addStateSpace(stateStr)
            # self$model[make.keys(stateStr)] <- hash(pi = NA, actions = hash())
         } 
         self$model[[stateStr]]$actions[[actionStr]] <- list(r = r, pr = pr)
         return(invisible(NULL))
      },
      
      #' @description Set the state-value of states
      #' @param stateStr A vector of state keys.
      #' @param value The value.
      setStateValue = function(stateStr = keys(self$model), value = 0) {
         self$v[stateStr] <- value
         return(invisible(NULL))
      },
      
      #' @description Set the policy to a random determistic policy.
      setRandomDeterministicPolicy = function() {
         stateStr = keys(self$model)
         for (s in stateStr) {
            self$model[[s]]$pi <- 1
            names(self$model[[s]]$pi) <- sample(self$getActionKeys(s), 1)
         }
         return(invisible(NULL))
      },
      
      #' @description Set a deterministic policy
      #' @param sa A named vector with action keys and names equal state keys-
      setDeterministicPolicy = function(sa) {
         states <- names(sa)
         pi = 1
         for (i in 1:length(sa)) {
            names(pi) <- sa[i]
            s <- states[i]
            self$model[[s]]$pi <- pi
         }
         return(invisible(NULL))
      },
      
      #' @description Return the state keys
      getStateKeys = function() {
         keys(self$model)
      },
      
      #' @description Return the action keys
      #' @param s The state considered.
      getActionKeys = function(s) {
         keys(self$model[[s]]$actions) 
      },
      
      #' @description Return the expected reward and trans pr of actions in a state
      #' @param s The state considered.
      getActionInfo = function(s) {
         as.list(self$model[[s]]$actions) 
      },
      
      #' @description Return the current policy as a tibble
      getPolicy = function() {
         # if (all(sapply(self$model, FUN = function(s) {s$pi}) == 1)) { # deterministic policy
         #    sapply(self$model, FUN = function(s) {names(s$pi)})
         # } else {
         map_dfr(self$getStateKeys(), .f = function(s) {
               list(state = s, action = names(self$model[[s]]$pi), pr = self$model[[s]]$pi)
            })
      },
      
      #' @description Return the state-values as a tibble
      #' @param s A vector of state keys.
      getStateValues = function(s = keys(self$v)) {
         tibble(state = s, v = values(self$v, keys = s))
      },
      
      #' @description Return a matrix with trans pr for a given action. 
      #' @param a Action key.
      getTransPrActionMat = function(a) {
         states <- keys(self$model)
         m <- matrix(0, nrow = length(states), ncol = length(states))
         colnames(m) <- states
         rownames(m) <- states
         for (s in states) {
            m[s, names(self$model[[s]]$actions[[a]]$pr)] <- self$model[[s]]$actions[[a]]$pr
         }
         return(m)
      },
      
      #' @description Returns all rewards in a matrix
      getRewardMat = function() {
         states <- keys(self$model)
         actions <- unique(unlist(sapply(states, function(s) self$getActionKeys(s))))
         m <- matrix(NA, nrow = length(states), ncol = length(actions))
         colnames(m) <- actions
         rownames(m) <- states
         for (s in states) {
            for (a in self$getActionKeys(s)) {
               m[s, a] <- self$model[[s]]$actions[[a]]$r
            }
         }
         return(m)
      },
      
      #' @description Bellman calculations for a given state and action
      #' @param gamma Discount rate.
      #' @param s State key.
      #' @param a Action key.
      bellmanCalc = function(gamma, s, a) {
         pr <- self$model[[s]]$actions[[a]]$pr
         r <- self$model[[s]]$actions[[a]]$r
         nS <- names(pr)
         vS <- values(self$v, nS)
         return(r + gamma * sum(pr * vS))
      },
      
      #' @description Iterative policy evaluation of current policy (defined by pi)
      #' @param gamma Discount rate.
      #' @param theta Threshold parameter.
      #' @param maxIte Maximum number of iterations.
      #' @param reset If true set all state-values to 0.
      policyEval = function(gamma, theta = 0.00001, maxIte = 10000, reset = TRUE) {
         if (reset) self$setStateValue()  # set to 0
         for (ite in 1:maxIte) { 
            delta <- 0   # Bellman error 
            for (s in keys(self$model)) {
               v <- self$v[[s]]  
               # update
               pi <- self$model[[s]]$pi
               actions <- names(pi)
               val =  0
               for (a in actions) {
                  # pr <- self$model[[s]]$actions[[a]]$pr
                  # r <- self$model[[s]]$actions[[a]]$r
                  # nS <- names(pr)
                  # vS <- values(self$v, nS)
                  val <- val + pi[a] * self$bellmanCalc(gamma, s, a)
               }
               self$v[[s]] <- val
               delta <- max(delta, abs(v-val))
            }
            if (delta < theta) break
         }
         if (ite == maxIte) warning("Policy evaluation algorithm stopped at max iterations allowed:", maxIte)
      },


      #' @description Policy iteration using iterative policy eval
      #' @param gamma Discount rate.
      #' @param theta Threshold parameter.
      #' @param maxIteEval Maximum number of iterations when evaluate policy.
      #' @param maxItePolicy Maximum number of policy iterations.
      policyIte = function(gamma, theta = 0.00001, maxIteEval = 10000, maxItePolicy = 100) {
         self$setRandomDeterministicPolicy()
         for (ite in 1:maxItePolicy) {
            self$policyEval(gamma, theta, maxIteEval, reset = FALSE)
            stable <- TRUE
            for (s in keys(self$model)) {
               piOld <- names(self$model[[s]]$pi)
               actions <- self$getActionKeys(s)
               vMax =  -Inf
               for (a in actions) {
                  val <- self$bellmanCalc(gamma, s, a)
                  if (val > vMax) {
                     names(self$model[[s]]$pi) <- a
                     vMax <- val
                  }
               }
               if (piOld != names(self$model[[s]]$pi) ) stable <- FALSE
            }
            if (stable) break
         }
         if (ite == maxItePolicy) warning("Policy Iteration algorithm stopped at max iterations allowed:", maxItePolicy)
         message(str_c("Policy iteration algorihm finished in ", ite, " iterations."))
         return(invisible(NULL))
      },
      
      #' @description Value iteration
      #' @param gamma Discount rate.
      #' @param theta Threshold parameter.
      #' @param maxIte Maximum number of iterations.
      #' @param reset If true initialize all state-values to 0.
      valueIte = function(gamma, theta = 0.00001, maxIte = 10000, reset = TRUE) {
         self$setRandomDeterministicPolicy()
         if (reset) self$setStateValue()  # set to 0
         for (ite in 1:maxIte) { 
            delta <- 0   # Bellman error 
            for (s in keys(self$model)) {
               v <- self$v[[s]]  
               actions <- self$getActionKeys(s)
               vMax =  -Inf
               for (a in actions) {
                  val <- self$bellmanCalc(gamma, s, a)
                  if (val > vMax) {
                     vMax <- val
                     names(self$model[[s]]$pi) <- a
                  }
               }
               self$v[[s]] <- vMax
               delta <- max(delta, abs(v-vMax))
            }
            if (delta < theta) break
         }
         if (ite == maxIte) warning("Value iteration algorithm stopped at max iterations allowed:", maxIte)         
         message(str_c("Value iteration algorihm finished in ", ite, " iterations."))
         return(invisible(NULL))
      }
   )
)
```

```{r, include=FALSE, eval=FALSE}
env <- RLEnvSeasonal$new(maxInv = 200, maxT = 15, scrapPrice = 5, purchasePrice = 14, prices  = c(10,15,20,25))
mdp <- MDPClass$new()      # initialize mdp object
mdp$addStateSpace(env$getStates())   # add states (states are keys in a hash and are always converted to strings), 101 represent finished
for (s in mdp$getStateKeys()) {  # add actions for each state (only the key of the action)
   mdp$addActionSpace(s, env$getActions(s))
} 
# check some of the keys
mdp$getActionKeys("0")
mdp$getActionKeys("2,1")


for (s in mdp$getStateKeys()) {
   cat(s, " ")
   for (a in mdp$getActionKeys(s)) {
      lst <- env$getTransPrR(s, a, runs = 1000)
      mdp$addAction(s, a, r = lst$r, pr = lst$pr)
   }
}
mdp$getActionInfo("0")
mdp$getActionInfo("20,1")
```

Let us try to find the optimal policy using policy iteration:

```{r, include=FALSE, eval=FALSE}
mdp$policyIte(gamma = 1)
mdp$getPolicy()
mdp$getStateValues()
df <- left_join(mdp$getStateValues(), mdp$getPolicy(), by = "state") %>% 
   select(-pr) %>% 
   separate(state, into = c("q", "t"), remove = F, convert = T) 
df %>% filter(q == 200)

df %>% 
   ggplot(aes(x = t, y = q, col = action)) +
   geom_point()
```





We consider seasonal product such as garden furnitures. Assume that the maximum inventory level is $Q$ items, i.e. we can buy at most $Q$ items at the start of the season for a price of $`r env$purchasePrice`. The product can be sold for at most $T$ weeks and at the end of the period (week $T$), the remaining inventory is sold to an outlet store for $`r env$scrapPrice` per item. 

The demand depends on the sales price which based on historic observations is assumed in the interval $[10,25]$. In general a higher sales price result in a lower demand. Moreover, in the first half part of the season the demand is on average 10% higher given a fixed sales price compared to the last half part of the season. Historic observed demands can be seen in Figure \@ref(fig:demand). 

```{r demand, echo=FALSE, fig.cap="Observed demands given price.", include=FALSE, eval=FALSE}
# df1 <- tibble(price = 10:25, stoc = F) %>% rowwise() %>% 
#    mutate(demand = env$getDemand(price, stochastic = F)) 
df1 <- tibble(price = rep(10:25, 200), t = "First half of season") %>% 
   rowwise() %>% 
   mutate(demand = env$getDemand(price, 1)) 
df2 <- tibble(price = rep(10:25, 200), t = "Last half of season") %>% 
   rowwise() %>% 
   mutate(demand = env$getDemand(price, 25)) 
df <- bind_rows(df1, df2) %>% 
   count(price, demand, t) 
df %>% 
   ggplot(aes(x = price, y = demand)) + 
   geom_smooth(se = F, lwd = 0.5, col = "grey") + 
   geom_point() +
   facet_grid(cols = vars(t))
```
   
   
Let $s = (q,t)$ denote the state of the system in the start of a week, where $q$ is the inventory and $t$ the week number. Then the state space is $$\mathcal{S} = \{ s = (q,t) | 1 \leq q \leq Q, 1 \leq t \leq T \} \cup \{ 0 \},$$
where state $s = 0$ denote the terminal state (inventory empty).
Possible actions are $$\mathcal{A}(q,t) = \{ 10,\ldots,25 \}, \mathcal{A}(0) = \{ d \}, $$ where action $d$ denote the dummy action with deterministic transition to state $0$.

The inventory dynamics for transitions not to the terminal state are $$t' = t + 1, q' = q - min(q, D),$$ 
where $D$ denote the demand. Moreover, if $t = T$ or $q'  = 0$, then a transition to the terminal state happens.  

For $t=1$ the reward of an state $(q,t)$ is sales price times the number of sold items minus the purchase cost. For $1<t<T$ the reward is sales price times the number of sold (we assume an inventory cost of zero), while for $t=T$ the reward is the scrap price times the inventory. 

```{r, include=FALSE, eval=FALSE}
library(R6)
library(hash)
library(tidyverse)

RLAgent <- R6Class("RLAgent",
   public = list(
      #' @field model The model is used to represent the information we have. The model is represented 
      #' using a hash list for the states. Each states contains a list with `actions`: a hash 
      #' list with actions and `pi` a vector with policy pr (named vector with only 
      #' positive values) and `piG` the greedy action. The `actions` hash list contains the action-values `q` and and counter `n`.
      model = NULL,  
      
      #' @description Create an object (when call new).
      initialize = function() {
         self$model <- hash()
         return(invisible(NULL))
      },

      #' @description Add state and action to the hash (only if not already added)
      #' @param s State key/string.
      #' @param a Action key/string.
      addStateAction = function(s, a) {
         if (!has.key(s, self$model)) addStates(s)
         if (!has.key(a, self$model[[s]]$actions)) self$model[[s]]$actions[[a]] <- list(q = 0, n = 0)
         return(invisible(NULL))
      },
      
      #' @description Add the states (keys) and define void policy and empty action hash. 
      #' @param states A vector of states (converted to strings).
      addStates = function(states) {
         keys <- make.keys(states)
         self$model[keys] <- list(pi = NA)   # don't use pi = NULL since then won't be defined 
         for (s in keys) {
            self$model[[s]]$piG <- NA
            self$model[[s]]$actions <- hash()
         }
         return(invisible(NULL))
      },
      
      #' @description Add the actions to a state
      #' @param s State (key).
      #' @param actions A vector of actions (converted to strings).
      addActions = function(s, actions) {
         keys <- make.keys(actions)
         for (a in keys) {
            self$addStateAction(s, a)
         }
         return(invisible(NULL))
      },
      
      #' @description Add states and actions to the hash with initial values. If already exists nothing happens. 
      #' @param df A tibble with string columns `s` (states) and `a` (actions).
      addStatesAndActions = function(df) {
         for (i in 1:nrow(df)) {
            self$addStateAction(df$s[i], df$a[i])
         }
         return(invisible(NULL))
      },
      
      #' @description Set the action-values for all actions (including the counter values).
      #' @param value The value.
      #' @param ctrValue Counter value.
      setActionValue = function(value = 0, ctrValue = 0) {
         for (s in keys(self$model)) {
            for (a in keys(self$model[[s]]$actions)) {
               self$model[[s]]$actions[[a]]$q = value
               self$model[[s]]$actions[[a]]$n = ctrValue
            }
         }
         return(invisible(NULL))
      },
      
      #' @description Set the policy to a random epsilon-greedy policy.
      #' @param eps Epsilon used in epsilon-greedy policy.
      setRandomEpsGreedyPolicy = function(eps) {
         states <- keys(self$model)
         for (s in states) {
            actions <- self$getActionKeys(s)
            self$model[[s]]$pi <- rep(eps/length(actions), length(actions))
            names(self$model[[s]]$pi) <- actions
            self$model[[s]]$piG <- sample(self$getActionKeys(s), 1)
            self$model[[s]]$pi[self$model[[s]]$piG] <- self$model[[s]]$pi[self$model[[s]]$piG] + 1 - eps
         }
         return(invisible(NULL))
      },
      
      #' @description Set the policy to the optimal epsilon-greedy policy 
      #' @param eps Epsilon used in epsilon-greedy policy.
      #' @param states States under consideration.
      setEpsGreedyPolicy = function(eps, states) {
         for (s in states) {
            actions <- self$getActionKeys(s)
            self$model[[s]]$pi <- rep(eps/length(actions), length(actions))
            names(self$model[[s]]$pi) <- actions
            idx <- nnet::which.is.max(unlist(values(self$model[[s]]$actions)["q",]))  # choose among max values at random
            # idx <- which.max(unlist(values(self$model[[s]]$actions)["q",]))  # choose first max 
            self$model[[s]]$piG <- actions[idx]
            self$model[[s]]$pi[idx] <- self$model[[s]]$pi[idx] + 1 - eps
         }
         return(invisible(NULL))
      },
      
      #' @description Return the state keys
      getStateKeys = function() {
         keys(self$model)
      },
      
      #' @description Return the action keys
      #' @param s The state considered.
      getActionKeys = function(s) {
         keys(self$model[[s]]$actions) 
      },
      
      #' @description Return information stored in a state
      #' @param s The state considered.
      getActionInfo = function(s) {
         as.list(self$model[[s]]$actions) 
      },
      
      #' @description Return the current policy as a tibble
      getPolicy = function() {
         map_dfr(self$getStateKeys(), .f = function(s) {
               list(state = s, action = names(self$model[[s]]$pi), pr = self$model[[s]]$pi)
            })
      },
      
      #' @description Returns all action-values in a matrix (cols: actions, rows: states)
      getStateActionQMat = function() {
         states <- keys(self$model)
         actions <- unique(unlist(sapply(states, function(s) self$getActionKeys(s))))
         m <- matrix(NA, nrow = length(states), ncol = length(actions))
         colnames(m) <- actions
         rownames(m) <- states
         for (s in states) {
            for (a in self$getActionKeys(s)) {
               m[s, a] <- self$model[[s]]$actions[[a]]$q
            }
         }
         return(m)
      },
      
      #' @description Return the action-values as a tibble
      #' @param states A vector of state keys.
      getActionValues = function(states = keys(self$model)) {
         map_dfr(states, .f = function(s) {
               list(state = s, action = keys(self$model[[s]]$actions), q = unlist(values(self$model[[s]]$actions)["q",]), n = unlist(values(self$model[[s]]$actions)["n",]))
            })
      },
      
      #' @description Generalized policy iteration using on policy Monte Carlo sampling and epsilon-greedy policies.
      #' @param env The environment that have a method `getEpisode` that return a tibble with cols s, a, r (last col the terminal reward)
      #' @param gamma Discount rate.
      #' @param epsilon Use epsilon-greedy policy.
      #' @param theta Threshold parameter.
      #' @param maxIte Maximum number of iterations.
      #' @param reset If true initialize all action-values to 0.
      gpiOnPolicyMC = function(env, gamma = 1, epsilon = 0.1, theta = 0.00001, maxIte = 10000, reset = TRUE, ...) {
         # if (reset) self$setActionValue(max(env$prices) * env$maxInv, 2)   # set to 0 and reset counter
         if (reset) self$setActionValue()   # set to 0 and reset counter
         self$setRandomEpsGreedyPolicy(epsilon)
         for (ite in 1:maxIte) { 
            stable <- TRUE
            delta <- 0
            df <- env$getEpisode(self, ...)   # an episode stored in a tibble with cols s, a, r (last col the terminal reward)
            # df <- df %>% mutate(oldQ = NA, q = NA, g = NA)
            gain <- 0
            for (i in nrow(df):1) {
               s <- df$s[i]
               a <- df$a[i]
               # self$addStateAction(s,a)
               gain <- df$r[i] + gamma * gain
               self$model[[s]]$actions[[a]]$n <- self$model[[s]]$actions[[a]]$n + 1
               ctr <- self$model[[s]]$actions[[a]]$n
               oldV <- self$model[[s]]$actions[[a]]$q
               self$model[[s]]$actions[[a]]$q <- oldV + 1/ctr * (gain - oldV)
               delta <- max(delta, abs(oldV - self$model[[s]]$actions[[a]]$q))
               oldPiG <- self$model[[s]]$piG
               self$setEpsGreedyPolicy(epsilon, s)
               if (oldPiG != self$model[[s]]$piG) stable = FALSE 
               # df$oldQ[i] <- oldV; df$q[i] <- self$model[[s]]$actions[[a]]$q; df$g[i] <- gain
               # cat("s:", s, " a:", a, " oldQ:", oldV, " q:", self$model[[s]]$actions[[a]]$q, "\n", sep="")
            }
            # print(df)
            # if (delta < theta & stable) break
            
         }
         if (ite == maxIte) warning("GPI algorithm stopped at max iterations allowed:", maxIte)
         message(str_c("GPI algorihm finished in ", ite, " iterations."))
         return(invisible(NULL))
      }
      

   )
)
```


We define the RL agent:

```{r, include=FALSE, eval=FALSE}
env <- RLEnvSeasonal$new(maxInv = 200, maxT = 20, scrapPrice = 5, purchasePrice = 14)
agent <- RLAgent$new()
agent$addStates(env$getStates())   # add state keys
for (s in agent$getStateKeys()) {
   agent$addActions(s, env$getActions(s))
} 
agent$addActions("0", "dummy")
agent$getStateKeys()
agent$getActionKeys("2,5")
agent$getActionKeys("2,20")
agent$getActionInfo("2,20")
agent$setRandomEpsGreedyPolicy(0.1)
agent$getPolicy()
```

Given the current policy an episode can be extracted using: 

```{r, include=FALSE, eval=FALSE}
env$getEpisode(agent)
```




```{r, include=FALSE, eval=FALSE}
agent$gpiOnPolicyMC(env, epsilon = 0.1, maxIte = 10000, q = env$maxInv)
df <- agent$getActionValues() %>% 
   separate(state, sep = ",", into = c("inv", "t"), remove = F, convert = T)
# df %>% filter(q>0)
# df %>% filter(t == 1) %>% print(n=80)
# 
# df %>% 
#    count(state) 
# 
df %>%
   filter(state == "200,1") %>% pull(n) %>% sum
df %>%
   filter(state == "200,1")

df1 <- df %>% 
   group_by(state) %>% 
   # nest() %>% 
   slice_max(q) %>% 
   filter(q != 0)  
# %>% 
#    mutate(action = as.numeric(action))

df1 %>% 
   ggplot(aes(x = t, y = inv, col = action)) +
   geom_point()
```












```{r links, child="links.md", include=FALSE}
```
